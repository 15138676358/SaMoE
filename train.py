"""
train.py
# This module is responsible for training the models defined in models.py using synthetic data generated by data_generator.py.
The batch data is generated by the data_generator module, and the training process is managed by this script.
"""

import torch
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
from data_generator import generate_synthetic_data
from models import End2EndModel, MoEModel, SaMoEModel
import numpy as np

def train_epoch(model, train_data_loader, test_data_loader, criterion, optimizer):
    """
    Train the model for one epoch.
    
    Args:
        model (nn.Module): The model to train.
        data_loader (DataLoader): DataLoader providing the training data.
        criterion (nn.Module): Loss function.
        optimizer (torch.optim.Optimizer): Optimizer for updating model parameters.
    """
    model.train()
    train_loss, test_loss = 0.0, 0.0
    
    for context, input_data, output_gt in train_data_loader:
        context = context.float()
        input_data = input_data.float()
        output_gt = output_gt.float()
        
        optimizer.zero_grad()
        
        # Forward pass
        output = model(context, input_data)
        
        # Compute loss
        loss = criterion(output, output_gt)
        
        # Backward pass and optimization
        loss.backward()
        optimizer.step()
        
        train_loss += loss.item()
    
    # Evaluate on test data
    model.eval()
    with torch.no_grad():
        for context, input_data, output_gt in test_data_loader:
            context = context.float()
            input_data = input_data.float()
            output_gt = output_gt.float()
            
            output = model(context, input_data)
            loss = criterion(output, output_gt)
            test_loss += loss.item()
    
    return train_loss / len(train_data_loader), test_loss / len(test_data_loader)

def train(model, train_data, test_data, batch_size=32, num_epochs=100, learning_rate=0.001):
    """
    Train the model on the provided training data.
    
    Args:
        model (nn.Module): The model to train.
        train_data (tuple): Tuple containing context, input_data, and output_gt.
        batch_size (int): Size of each training batch.
        num_epochs (int): Number of epochs to train the model.
        learning_rate (float): Learning rate for the optimizer.
    """
    context, input, output_gt = train_data
    train_dataset = TensorDataset(context, input, output_gt)
    train_data_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    context, input, output_gt = test_data
    test_dataset = TensorDataset(context, input, output_gt)
    test_data_loader = DataLoader(test_dataset, batch_size=len(test_dataset), shuffle=False)
    
    criterion = torch.nn.MSELoss()
    optimizer = optim.Adam(model.parameters(), lr=learning_rate)
    
    for epoch in range(num_epochs):
        train_loss, test_loss = train_epoch(model, train_data_loader, test_data_loader, criterion, optimizer)
        print(f'Epoch [{epoch+1}/{num_epochs}], Train Loss: {train_loss:.4f}, Test Loss: {test_loss:.4f}')

def main():
    # load dataset from .npz file
    data = np.load('train_data.npz')
    context, input, output_gt = torch.tensor(data['context']), torch.tensor(data['input']), torch.tensor(data['output_gt'])
    train_data = (context, input, output_gt)
    data = np.load('test_data.npz')
    test_context, test_input, test_output_gt = torch.tensor(data['context']), torch.tensor(data['input']), torch.tensor(data['output_gt'])
    test_data = (test_context, test_input, test_output_gt)
    
    # Initialize model
    # model = End2EndModel(context_size=8, hidden_size=32, output_size=1)
    model = MoEModel(num_experts=40, context_size=8, input_size=1, hidden_size=32, output_size=1)
    
    # Train the model
    train(model, train_data, test_data, batch_size=16, num_epochs=100, learning_rate=0.001)

    # Save the trained model
    torch.save(model.state_dict(), 'trained_model.pth')

if __name__ == "__main__":
    main()